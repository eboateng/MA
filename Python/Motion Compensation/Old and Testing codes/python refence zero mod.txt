
# load library
# give location of dll
PS30 = windll.LoadLibrary("ps30.dll")

# open virtual serial interface (or serial interface via tcp/ip socket)
if ps30ComPort==0: # find first connected control unit
    result1=PS30.PS30_SimpleConnect(1, b"") # ANSI/Unicode !!
elif ps30ComPort==-1: # find the first connected control unit via tcp/ip socket (localhost, port=1200)
    result1=PS30.PS30_SimpleConnect(1, b"net") # ANSI/Unicode !!
else: # connect control unit with defined COM port
    result1=PS30.PS30_Connect(1, 0, ps30ComPort, 115200,0,0,0,0)

# define constants for calculation Inc -> mm
#(rotary measuring stage + step motor without encoder: revolution = 360.0 degrees, full steps/rev = 200, ratio =180.0):
# result1= PS30.PS30_SetStageAttributes(1, ax1, c_double(360), 200, c_double(180))
# print(result1)
# result1= PS30.PS30_SetStageAttributes(1, ax2, c_double(360), 200, c_double(180))
# print(result1)

dValue = PS30.PS30_GetPositionEx(1,2)
print("Current Position ax2 is ", 0.0072*dValue)

# load param file
if nExport==2:
    result1=PS30.PS30_LoadTextFile(1, ax1, b"ps30_params_export.txt") # ANSI/Unicode !!

# initialize axis
result1=PS30.PS30_MotorInit(1, ax1)
result1=PS30.PS30_MotorInit(1, ax2)

# save param file
if nExport==1:
    result1=PS30.PS30_SaveTextFile(1, ax1, b"ps30_params_export.txt") # ANSI/Unicode !!



##PS30_GetPositionEx=PS30.PS30_GetPositionEx
##PS30_GetPositionEx.restype = ctypes.c_double
##result2=PS30_GetPositionEx(1, nAxis)
##result3=PS30_GetPositionEx(1, 1)
##print("Position=%.3f" %(result2))

#check if reference run was previously executed
# TBD

##start positioning
PS30.PS30_GoRef(1, ax1, 6)
PS30.PS30_GoRef(1, ax2, 6)
time.sleep(0.5)

state1 = PS30.PS30_GetMoveState(1, ax1)
state2 = PS30.PS30_GetMoveState(1, ax2)

while state1 != 0 or state2 != 0:
    state1 = PS30.PS30_GetMoveState(1,ax1)
    state2 = PS30.PS30_GetMoveState(1,ax2)

error = PS30.PS30_SetPosMode(1,ax1,0);
error = PS30.PS30_SetPosMode(1,ax2,0);

# set target mode (0 - relative)
PS30.PS30_SetTargetMode(1, ax1, 0)
PS30.PS30_SetTargetMode(1, ax2, 0)

dValue1 = PS30.PS30_GetPosRangeEx(1,ax1)
print("Range ax1", dValue1)
dValue2 = PS30.PS30_GetPosRangeEx(1,ax2)
print("Range ax1", dValue2)


PS30.PS30_SetTarget(1, ax1, c_double(dZero))
PS30.PS30_SetTarget(1, ax2, c_double(dZero))

result = PS30.PS30_MoveEx(1, ax1, c_double(dZero), 1)
result = PS30.PS30_MoveEx(1, ax2, c_double(dZero), 1)

#save the zero position
z1 = 0.0072 * PS30.PS30_GetPositionEx(1,ax1)
z2 = 0.0072 * PS30.PS30_GetPositionEx(1,ax2)

PS30.PS30_SetPositionEx(1,1,0);
PS30.PS30_SetPositionEx(1,2,0);

print("Position angle",z1)

long_value = PS30.PS30_GetAccelEx(1,ax1)
print("Current Accelparam ax1", long_value)
#long_error = PS30.PS30_SetAccel(1,ax1,2000)

long_value = PS30.PS30_GetAccelEx(1,ax2)
print("Current Accelparam ax2", long_value)
#long_error = PS30.PS30_SetAccel(1,ax2,2000)


long_value = PS30.PS30_GetAccelEx(1,ax1)
print("New Accelparam ax1", long_value)
#long error = PS30_SetAccel(1,ax1,2000)

long_value = PS30.PS30_GetAccelEx(1,ax2)
print("New Accelparam ax2", long_value)

#long error = PS30_SetAccel(1,ax1,3600);
#long error = PS30_SetAccel(1,ax2,3600);

